Q1. What is reused in your modified code, and what is it reused across?

oacts is now reused when s, r, c are incremented, while other variables
do not change.

wts is now reused even when c, k, x, y, do not change, while s, r, n are incrementing,
depending on whether a line of size CONV2_S and CONV2_R fit in the cache.
Since CONV2_S * CONV2_R = 3*3 = 9, there is some spatial and temporal reuse,
since it fits in two cache lines between reuses, though it may be evicted
more sometimes.

iacts can be reused if n, c, do not change. There is some reuse when
y+s is equal to some previously fetched cache line (e.g. y=0, s = 1, and s = 1, y = 0)
and similarly to x+r. Since we know that CONV2_S and CONV2_R are size 3 each, it is highly likely
that some unintentional temporal reuse can be obtained here as the values can
fit in the cache without being evicted (2 cache lines).

Q2. Calculate the expected L1 data cache read miss rate in conv2 before and after your modifications. Explain in detail why you expect this miss rate; unsupported answers will receive no credit.
Before
oacts has esesntially 0 reuse since it jumps by CONV2_K * IN3_X * IN3_Y = 36,864 elements in the innermost loop, which
happens the most often. The miss rate is 1.

wts also has essentially 0 spatial reuse, since it jumps by CONV2_C * CONV2_S * CONV2_R = 288 elements
in the second innermost loop. However, there is some temporal reuse since n increments by batch_sz times using
wts for that amount, which is 100 times. The miss rate is 1/100. 

iacts has essentially has 0 spatial reuse, since it jumps by CONV2_C * IN2_X * IN2_Y = 21362 elements per inner loop.
Therefore, it has a miss rate of 1. 

Thus, the overall miss rate is (1 + 1/100 + 1)/3 = ~66%

After:
Oacts:
Since there is spatial reuse since x is incremented the most often and is adjacent, 1 cache line contains 8 values, so
there are approximately 1 cache miss per 8 cache accesses, so a 1/8 miss rate. But, there is some temporal reuse
while s, r, are incrementing. 

Iacts:
First, there is spatial reuse since r is incremented the most often, so array accesses are adjacent, so the 
initial miss rate is 1/8. 

There is some temporal reuse since there are many combinations where x1+r1=x2+r2 that allows for reuse. For example, 
the most common case is something like x+r=3, where we can find 3 different x, r combinations that have the same index. 

So, the reuse of this component is 1/3.

similarly, there is some temporal reuse where y+s acts in a similar way as above. The reuse component, we estimate is also
around 1/3, with a slightly higher miss rate since sometimes elements get evicted. 

The miss rate here is approximately 1/(8*3*3) = 1/72

We can neglect the miss rate, or miss rate = 0 

wts:
When wts is accessed, one cache line of 8 is brought in. They can be used right away spatially as s, r are incremented.
So, the miss rate is around ~1/8


Q3. Explain any differences between your expected and measured L1 data cache read miss rates.
I believe there differences because sometimes elements in iacts may be evicted by other data between the "temporal"
reuses that I assume, since they are sometimes far apart, especially with the y+s combinations. 



